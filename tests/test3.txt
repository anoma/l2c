(function cadr (l) [car [cdr l]])
(function caadr (l) [car [cadr l]])
(function cadadr (l) [car [cdr [cadr l]]])
(function cddr (l) [cdr [cdr l]])
(function cdddr (l) [cdr [cddr l]])
(function cdar (l) [cdr [car l]])
(function cadar (l) [car [@cdar l]])
(function caddar (l) [car [cdr [cdar l]]])
(function caddr (l) [car [cdr [cdr l]]])
(function cadddr (l) [car [cdr [cdr [cdr l]]]])
(function caddddr (l) [car [cdr [cdr [cdr [cdr l]]]]])
(function cadddddr (l) [car [cdr [cdr [cdr [cdr [cdr l]]]]]])
(function caar (l) [car [car l]])
(function coons (a b c) [cons a [cons b c]])
(function cooons (a b c d) [cons a [coons b c d]])
(function coooons (a b c d e) [cons a [cooons b c d e]])
(function cooooons (a b c d e f) [cons a [coooons b c d e f]])
(function coooooons (a b c d e f g) [cons a [cooooons b c d e f g]])
(function cooooooons (a b c d e f g h) [cons a [coooooons b c d e f g h]])

(* Macro to convert a value into a literal expression that creates it. *)

(function =# (binary)
  [cons [cooooooons -l- -i- -t- -e- -r- -a- -l- nil]
    [cons (with return {(continuation write (count in out)
        (if count
          {write [- count (literal 00000000000000000000000000000001)]
            [>> in (literal 00000000000000000000000000000001)]
            [cons (if [& in (literal 00000000000000000000000000000001)]
              -1- -0-) out]}
          {return out}))
        (literal 00000000000000000000000000100000) binary nil})
      nil]])

(* Macro to convert a value in decimal into a literal expression. *)

(function # (l) [=#
  (with return {(continuation read (in out)
    (if [null? in]
      {return out}
      {read [cdr in] [+ [* out (literal 00000000000000000000000000001010)]
        (if [char= [car in] -9-] (literal 00000000000000000000000000001001)
        (if [char= [car in] -8-] (literal 00000000000000000000000000001000)
        (if [char= [car in] -7-] (literal 00000000000000000000000000000111)
        (if [char= [car in] -6-] (literal 00000000000000000000000000000110)
        (if [char= [car in] -5-] (literal 00000000000000000000000000000101)
        (if [char= [car in] -4-] (literal 00000000000000000000000000000100)
        (if [char= [car in] -3-] (literal 00000000000000000000000000000011)
        (if [char= [car in] -2-] (literal 00000000000000000000000000000010)
        (if [char= [car in] -1-] (literal 00000000000000000000000000000001)
          (literal 00000000000000000000000000000000))))))))))]}))
    [cadr l] (literal 00000000000000000000000000000000)})])


(* Macro to convert a value in hexadecimal into a literal expression. *)

(function 0x (l) [=#
  (with return {(continuation read (in out)
    (if [null? in]
      {return out}
      {read [cdr in] [+ [* out (literal 00000000000000000000000000010000)]
        (if [char= [car in] -F-] (literal 00000000000000000000000000001111)
        (if [char= [car in] -E-] (literal 00000000000000000000000000001110)
        (if [char= [car in] -D-] (literal 00000000000000000000000000001101)
        (if [char= [car in] -C-] (literal 00000000000000000000000000001100)
        (if [char= [car in] -B-] (literal 00000000000000000000000000001011)
        (if [char= [car in] -A-] (literal 00000000000000000000000000001010)
        (if [char= [car in] -9-] (literal 00000000000000000000000000001001)
        (if [char= [car in] -8-] (literal 00000000000000000000000000001000)
        (if [char= [car in] -7-] (literal 00000000000000000000000000000111)
        (if [char= [car in] -6-] (literal 00000000000000000000000000000110)
        (if [char= [car in] -5-] (literal 00000000000000000000000000000101)
        (if [char= [car in] -4-] (literal 00000000000000000000000000000100)
        (if [char= [car in] -3-] (literal 00000000000000000000000000000011)
        (if [char= [car in] -2-] (literal 00000000000000000000000000000010)
        (if [char= [car in] -1-] (literal 00000000000000000000000000000001)
          (literal 00000000000000000000000000000000))))))))))))))))]}))
    [cadr l] (literal 00000000000000000000000000000000)})])

(* Macro to convert an s-expression into an expression to generate it. *)

(function ` (l)
  [(function aux (s)
    (if [null? s] [cooons -n- -i- -l- nil]

    (if (if [null? s] #:0 (if [token? s] #:0 (if [null? [car s]]
      #:0 (if [char= [caar s] -,-] [null? [cdar s]] #:0))))
          [cadr s]

    [coooons [coooooons -i- -n- -v- -o- -k- -e- nil]
      [coooons -c- -o- -n- -s- nil]
        (if [token? s]
            [cooons --- [car s] --- nil]
            [aux [car s]])
          [aux [cdr s]] nil]))) [cadr l]])

(* Function to reverse a list. *)

(function meta.reverse (l)
  (with return
    {(continuation _ (l reversed)
      (if [null? l]
        {return reversed}
        {_ [cdr l] [cons [car l] reversed]})) l nil}))

(* Function to apply the given map to a list. *)

(function meta.map (l mapper)
  (with return
    {(continuation aux (in out)
      (if [null? in]
        {return [meta.reverse out]}
        {aux [cdr in] [cons [mapper [car in]] out]})) l nil}))

(* Macro to implement a let binding. *)

(function let (l)
  `:(with let.return
    ,:[coons `:jump `:(continuation let.aux ,:[meta.map [cdr [meta.reverse [cdr l]]] car]
      {let.return ,:[car [meta.reverse l]]}) [meta.map [cdr [meta.reverse [cdr l]]] cadr]]))

(* Macros for boolean constants. *)

(function false (l) [=# #:0])

(function true (l) [=# #:1])

(* Macro for short-circuit disjunction. *)

(function or (l) (with return
  {(continuation loop (l sexpr)
      (if [null? l]
        {return sexpr}
        {loop [cdr l] `:(let (or.temp ,:[car l]) (if or.temp or.temp ,:sexpr))}))
    [meta.reverse [cdr l]] `:(false)}))

(* Macro for short-circuit conjunction. *)

(function and (l) (with return
  {(continuation loop (l sexpr)
      (if [null? l]
        {return sexpr}
        {loop [cdr l] `:(let (and.temp ,:[car l]) (if and.temp ,:sexpr and.temp))}))
    [meta.reverse [cdr l]] `:(true)}))

(* Macro for logical negation. *)

(function not (l) `:(if ,:[cadr l] (false) (true)))

(* Macro to enable binding to multiple "return" values. *)

(function bind (l)
  `:(with bind.return
      {(continuation bind.temp (bind) ,:[caddr l])
        (continuation bind.cont ,:[cadr l] {bind.return ,:[cadddr l]})}))

(* Macro to do a named-let. *)

(function loop (l)
  (let (bindings [meta.reverse [cdr [meta.reverse [cddr l]]]])
    `:(with loop.return
        {(continuation ,:[cadr l] ,:[meta.map bindings car]
          {loop.return ,:[car [meta.reverse l]]}) , [meta.map bindings cadr]})))

(* Macro to sequence a set of expressions. *)

(function do (l)
  `:(with do.return
    ,:(loop make-do (acc `:{do.return do.arg}) (exprs [meta.reverse [cdr l]])
        (if [null? exprs]
          acc
          {make-do `:{(continuation do.cont (do.arg) ,:acc) ,:[car exprs]} [cdr exprs]}))))

(* Macro for selection control flow. *)

(function case (l)
  `:(let (case.= ,:[cadr l]) (case.val ,:[caddr l])
    ,:(with return
      {(continuation aux (remaining else-clause)
        (if [null? remaining]
          {return else-clause}
          {aux [cdr remaining]
            `:(if ,:[cons `:or [meta.map [cdr [meta.reverse [car remaining]]]
                (function _ (e) [coooons `:invoke `:case.= `:case.val e nil])]]
              ,:[car [meta.reverse [car remaining]]] ,:else-clause)}))
        [cdr [meta.reverse [cdddr l]]] [car [meta.reverse l]]})))

(* Macro for supporting character literals. *)

(function meta.char-aux (l) (case char= l
  (-!- #:33) (-"- #:34) (-#- #:35) (-$- #:36) (-%- #:37) (-&- #:38) (-'- #:39) (-*- #:42)
  (-+- #:43) (-,- #:44) (--- #:45) (-.- #:46) (-/- #:47) (-0- #:48) (-1- #:49) (-2- #:50)
  (-3- #:51) (-4- #:52) (-5- #:53) (-6- #:54) (-7- #:55) (-8- #:56) (-9- #:57)
  (-<- #:60) (-=- #:61) (->- #:62) (-?- #:63) (-@- #:64) (-A- #:65) (-B- #:66)
  (-C- #:67) (-D- #:68) (-E- #:69) (-F- #:70) (-G- #:71) (-H- #:72) (-I- #:73) (-J- #:74)
  (-K- #:75) (-L- #:76) (-M- #:77) (-N- #:78) (-O- #:79) (-P- #:80) (-Q- #:81) (-R- #:82)
  (-S- #:83) (-T- #:84) (-U- #:85) (-V- #:86) (-W- #:87) (-X- #:88) (-Y- #:89) (-Z- #:90)
  (-\- #:92) (-^- #:94) (-_- #:95) (-`- #:96) (-a- #:97) (-b- #:98) (-c- #:99) (-d- #:100)
  (-e- #:101) (-f- #:102) (-g- #:103) (-h- #:104) (-i- #:105) (-j- #:106) (-k- #:107) (-l- #:108)
  (-m- #:109) (-n- #:110) (-o- #:111) (-p- #:112) (-q- #:113) (-r- #:114) (-s- #:115) (-t- #:116)
  (-u- #:117) (-v- #:118) (-w- #:119) (-x- #:120) (-y- #:121) (-z- #:122) (-|- #:124) (-~- #:126)
  #:0))

(function char (l) [=# [meta.char-aux [caadr l]]])

(* Macro for supporting string literal. *)

(function " (l)
  (loop add-word (str [cdr l]) (index #:0) (exprs nil) (instrs nil) (buf #:0)
    (let (sub-index [% index #:4])
    (let (expr (loop build (instrs instrs) (expr [=# buf]) (if [null? instrs] expr {build [cdr instrs] `:[| ,:[car instrs] ,:expr]})))
    (let (next-exprs (if [== sub-index #:0] [cons expr exprs] exprs))
    (let (next-instrs (if [== sub-index #:0] nil instrs))
    (let (next-buf (if [== sub-index #:0] #:0 buf))
      (if [null? str] (let (buf [| next-buf [<< (nul) [* sub-index #:8]]])
        (let (expr (loop build (instrs next-instrs) (expr [=# buf]) (if [null? instrs] expr {build [cdr instrs] `:[| ,:[car instrs] ,:expr]})))
          [coons `:storage `:dquote.tmp [cdr [meta.reverse [cons expr next-exprs]]]]))

      (if (and [null? [car str]] [null? [cdr str]]) {add-word [cdr str] index exprs instrs buf}

      (if (and [null? [car str]] [token? [cadr str]])
        (let (buf [| next-buf [<< (space) [* sub-index #:8]]])
          {add-word [cdr str] [+ index #:1] next-exprs next-instrs buf})

      (if [null? [car str]] {add-word [cdr str] index exprs instrs buf}

      (if [token? [car str]] (let (buf [| next-buf [<< [meta.char-aux [caar str]] [* sub-index #:8]]])
        {add-word [cons [cdar str] [cdr str]] [+ index #:1] next-exprs next-instrs buf})

        {add-word [cdr str] [+ index #:1] next-exprs
          [cons `:[<< ,:[car str] ,:[=# [* sub-index #:8]]] next-instrs] next-buf}))))))))))))

(* Macro for null terminator. *)

(function nul (l) [=# #:0])

(* Macro for space character. *)

(function space (l) [=# #:32])

(* Some example code using the above macros. *)

(" hell(# 65)o)

(case == #:10 (#:2 #:200) (#:3 #:300) #:400)

(function sequence-things () (do [a] [b] [c] [d]))

(* Demonstrate an approach to returning multiple values. *)

(function div (a b return)
  {return [/ a b] [% a b]})

(* Compute bezout's identity. *)

(function bezout (a b return)
  (if [== a #:0]
    {return b #:0 #:1}
    (bind (c d) [div b a bind]
      (bind (e f g) [bezout d a bind]
        {return e [- g [* f c]] f}))))

(* Show how the bezout identity function could be called. *)

(function print-bezout (a b)
  (bind (c d e) [bezout a b bind]
    [print c d e]))

(* Use a named-let to compute a factorial. *)

(loop factorial-loop (n #:6) (acc #:1)
  (if [== n #:0]
    acc
    {factorial-loop [- n #:1] [* acc n]}))

(and #:3 #:4 #:5)

(or #:3 #:4)

(not #:0)

(let (x #:4) (y #:3) [* x y])

[* #:5 #:6]

(* A decimal value. *)

#:22

(* A hexadecimal value. *)

0x:FF
